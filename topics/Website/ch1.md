# How To Become A Programmer For Anybody: Website

## Chapter 1: The RunDown

Welcome to the portion of this reading that will be dissecting a modern website
built with JavaScript, implementing TypeScript in advanced versions. Through this,
you will given a chance to see what makes some modern web functionality work
behind the scenes, and see the considerations that can be taken into account
when building a system for such a purpose. We will use Next.js and React in
this program as well. Next.js handles the server and routing of web pages, and
React is a javascript library that handles the frontend presentation, animations, and interactions with the
visual representation of the site. There are actually several frontend libraries like React
in the programming community today. Many of them interact with HTML (HyperText Markup
Language, which is used to present things on a web page) to add logic. React was made by Facebook,
and used very commonly.

We will have brief introductions into HTML and CSS (Cascading Style Sheets) so that logic related
to positioning things on the web page are not too distracting for us to understand the logic
manipulating values on the page. After this introduction we will be installing vscode for our
IDE (Integrated Development Environment), and we will go over extensions that will be helpful
in the process. Following this, we will go into git for a bit so that we can pull the source code,
navigate within branches, and learn its general use. Once we have reached this point, you will then
have an understanding of the basics of web page presentation, have an appropriate learning setup,
and have the entirety of the code on your own machine.

With all of that in place, you will actually be able to run the code yourself and see a local
version of the website we will be studying and learning from. Once you are at this point, you
are free to explore every part of the site. I will also do my best to present each portion of
the site in a logical order that gradually builds in difficulty, but shares commonalities with
things we will have already seen. To preface, the final product of this site is in
TypeScript. It is not the most complicated TypeScript it could be, but having the type logic
on top of the Javascript logic may be a bit overwhelming at first. In smaller sections the opposite
may be true, but the longer sections will have many moving parts to keep track of.

Once the code is on your computer, you are free to play with it as you like as well. You can
comment parts out, change names, or move things around and see if such things lead to errors
or changes in behavior. This is often helpful if you are trying to make sense of a portion of code,
but you think you are missing something in the logic. You could also insert a `console.log()`, and see
what a value is at a certain time. Using git, you will be able to undo any changes you may make, so
you do not have to worry about breaking anything.

## Music Theor-ease

Our example site is named Music Theor-ease. If you are familiar with music, some of the terminology
may already be familiar to you, but there is no concern if this is not the case. Initially one of
my hopes to explain arrays was to use music scales and modes as examples, and you will see them
as we look through the site. You will have a chance to navigate the site freely once it is downloaded,
and explore all of its contents. With this site we will see examples of animations, UI/UX
(User Interface/Experience) practices, retrieving data, passing data between components,
design patterns, testing, and much more. It is my hope that the structure itself reveals how
many of these sites with large amounts of data and sections are able to be mass produced and maintained.

While going over the site we will go over all the design decisions that were made along the way,
and discuss when trade offs were made. Being able to create a site with an unlimited amount of time
allows for you to spend vast amounts of time on features you would like to add to your site. In
most professional settings, you most likely will not have unlimited time. This leads to optimizing your
time effectively and balancing what is a realistic expectation versus unrealistic. If you start to
notice that something is becoming painful or taking much longer than anticipated, sometimes there is
another choice that can give you a working solution much faster and simpler. By this I do not mean
to imply the easy route is being chosen, but more so that we can get stuck in situations where we
become blind to other acceptable alternatives. This can be the case for many situations, but often
it can be that you envisioned something a very particular way, only stopping once you have exactly
that. Having the conviction to follow things through and finish them is a very admirable trait, but you
need to realize when one of those things is stopping you from everything else.

This is actually one of the beauties of programming. We do our best to make sure something is great
and as perfect as it can be before we deliver it and present it to users (hopefully), but inevitably
things can go wrong. With code, we have the ability to update things and improve them over time.
This leaves room for you to create working solutions so that users can enjoy the benefits of the
software that you provide. So long as the software you created can be used, you may be able to generate
income so that you can spend time on improving parts of the system you wanted to allocate more time
to. Now you could always be making something just as a hobby, but it is a good exercise to be able
to know when to implement practical parts of a solution instead of never having a finished product.
